# Requirement

- Python3: 3.6 or later
- Icarus Verilog: 10.1 or later

```
sudo apt install iverilog
```

- Pyverilog

```
pip install pyverilog
```


# Introduction

So far (version 2019.2), Vivado HLS has adopted one single pipeline micro-architecture, where the whole pipeline will be stall if any stage does not meet the executing requirements. While simple and effective for small designs, this micro-architecture lacks scalability and will become a headache for large designs, as the `stall` signal must be broadcast to all elements of the pipeline. To address the issue, we need to adapt to other more efficient micro-architectures.

In our paper, we presented that switching to the skid-buffer-based pipeline will significantly improve the achievable frequency. However, it is non-trivial for users to make the change. While Xilinx is aware of the situation and has plan to improve their tool in future releases, right now there is nothing we can do except for hacking the RTL generated by HLS.

Therefore, we provide a sample script to automatically perform such conversion. As we are hacking from outside of HLS, our tool highly depends on the output format of HLS and may not cover every corner case. Currently we also require a specific coding style of the source code as a prerequisite. Our tool can also be a reference to expert users who want to modify the machine-generated RTL according to their needs.

# Detailed Instruction

Specifically, our tool can modify the micro-architecture of those pipelines that interact with `ap_fifo` interfaces. Most commonly this happens in the `#pragma HLS dataflow` environment. We will remove the `stall` signal, and implement a skid buffer for flow-control purpose.

## How to Run

Add the directory of your HLS source files and related configuration information to `run.py` and execute it.

## Coding Style

To make things easier, we require one tiny format that the source code must only use `non-blocking read`. To convert a blocking read to a non-blocking read, users can first test the emptyness of the target FIFO, then perform the `read_nb()` operation. Meanwhile, please do not use the `<<` or `>>` operators by Vivado HLS, which is equivalent to blocking write and blocking read respectively. An example that conforms to our coding style is:
```c++
for (long long i = 0; i < SIZE; ) {
  #pragma HLS pipeline II=1
  if (!in_port.empty()) {
    data_t temp;
    in_port.read_nb(temp); // non-blocking read
    out_port.write(temp); // it is OK for blocking write
    i++;
  }
}
```

## Format of Vivado HLS Output

As we need to parse multiple HLS-generated files, the parser is highly dependent on the output format. Thus we collect all functions that is format-sensitive into one class in `user_format.py`. If future release of HLS should change any formatting (e.g. naming convention of modules), we need to modify this part of our tool accordingly.

## How It Works

1. The tool will first replace all `write()` to `write_nb()`. This step is transparent to users, and users are free to use blocking write. We will fix the correctness issue later.

2. The tool will re-run HLS. At this time the design will only have non-blocking FIFO operations, thus the `stall` signal will be a constant `0`.


3. There is an ```enable``` signal for every stage of the pipeline. The following example shows the enable signal (```ap_enable_reg```) for the first stage (```iter0```) of the first pipeline (```pp0```). During normal execution, this signal will be passed to the enable for the second stage of the pipeline (```ap_enable_reg_pp0_iter1```)

```Verilog
// "enable" for the first stage of pipeline-0
always @ (posedge ap_clk) begin
  if (ap_rst) begin
    ap_enable_reg_pp0_iter0 <= 1'b0;
  end else begin
    if (...)
      ap_enable_reg_pp0_iter0 <= 1'b0;
    else if (...)
      ap_enable_reg_pp0_iter0 <= 1'b1;
  end
end

// "enable" for the second stage of pipeline-0
always @ (posedge ap_clk) begin
  if (ap_rst) begin
    ap_enable_reg_pp0_iter1 <= 1'b0;
  end else begin
    if (...) begin
      if (...)
        ap_enable_reg_pp0_iter1 <= 1'b0;
      else if ((1'b1 == 1'b1)) // passed from the first stage
        ap_enable_reg_pp0_iter1 <= ap_enable_reg_pp0_iter0;
    end
  end
end
```

4. What we need to do is to add flow control signals such as ```full_n``` to the enable signals. Note that we don't need to worry about ```empty_n``` due to the coding style introduced in step 1.

```Verilog
// "enable" for the first stage of pipeline-0
always @ (posedge ap_clk) begin
  if (ap_rst) begin
    ap_enable_reg_pp0_iter0 <= 1'b0;
  end else begin
    if (...)
      ap_enable_reg_pp0_iter0 <= 1'b0;
    else if (...)
      ap_enable_reg_pp0_iter0 <= 1'b1 & out_port_V_full_n;
    else 
      ap_enable_reg_pp0_iter0 <= 1'b1 & out_port_V_full_n;
  end
end
```

5. Finally, we need to add the skid buffer to complete the hacking. To do so, we can change the original downstream FIFO to an ```almost_full``` FIFO, where the ```full_n``` will be asserted while there are still capacity to accomodate more incoming data. Here the overprovision capacity should be no smaller than the length of the pipeline. Specicially we will generate a wrapper for each module, which includes the original module plus the required skid buffers.

## Integration with SDAccel / Vitis

After the tool modified the generated RTL, users can then pack the RTL into an `xo` object through the corresponding HLS script generated by the tool, which can be used directly by the SDAccel / Vitis flow.

```
VIV_VER=2019.2 vivado_hls -f pack_xo.tcl
```

